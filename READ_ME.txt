git: https://github.com/dor123456/nitrate_analysis

nitrate analysis documentation

phydrus_model_initializer:
Main part is a class that initializes a phydrus model based on a static config and dynamic config received as dicts. The dynamic config is built to be the dynamic dict that changes during the run while the static config is static. The class is built to create a hydrus simulation including water transport, solute transport, root uptake, and evapotranspiration. The functions of the class are each responsible of initializing one part in the hydrus package.
DynamicConfig is defined in the begininning of the file.

static_configuration.py where the static config is saved. Used through the python scripts.
midrasha_static_configuration.py where the static config that is supposed to represent the experiment in the midrasha is saved.

nitrate optimizer.py - the class that is supposed to decide the amount of fertigation and precipitation to give the model in order to achieve a stable watercontent and fertigation concentration at given depth. The class is subsequential. After an instance is initialized the run function takes care of the beginning configuration and then runs the simulation step by step. At the end the plot all function calls all the functions that plots graphs. Each step the phydrus model is initialized and run, and then the initial params for the next step are initialized based on the profile at the end of the previous step and the changing params that are updated in a predefined manner based on simulation_changing_params dict. Then the file that saves past data for decision making is updated, important information from the model is saved in order to be able to plot graphs and decide precipitation and fertigation intelligently. Lastly, the irrigation and fertigation for the next step are decided using there respective functions. In the main function two simulations are run, one with the pid algorithm and one with the static algorithm.
ET_Ovdat.csv - where we bring the evapotranspiration information from. Taken from the metoreological station in ovdat.

fertigation_optimization.py - the class has two main functionalities.
One is sensitivity analysis that the main part of it happens in create_variable_table. Each predefined variable is run with different values and we check the sensitivity of the NUE for these different variables. The values are saved in csvs so that we can run create_graphs_from_csv and get the graphs without rerunning the whole model each time.
Second functionality is the inverse solution. Here we have get_real_world_theta that extracts the watercontent from the expirement in the midrasha from cleaned_real_water_content_data.csv then in get_solute_variables the variables we want to do inverse solution for are defined. There are functions that calculates residuals and minimize them, and same for cost which is the sum of the residuals. The reason we have both residuals and cost minimize functions is that there are different algorithms for inverse solution, some request residuals and some cost functions. In valid_input_range we can define legal range for our parameters. In residual function we run the phydrus model with the initial parameters, then we take the theta/watercontent from the output at the end of the run and compare it with the real_world_theta, getting the residuals we want to minimize. The residuals are calculated for all predefined depths. Parameters and cost are saved in params_cost_hydro_10.txt in order to be able to track the changing of the params and cost function. Anytime something wierd happens for example the model doesn't run until the end the cost is defined to 100000000. 
NOTE: There are many different local minimums for the residuals- resulting in maybe non optimal parameters. Also the residual function maybe be unstable so that many minimize algorithms dont work. Specifically the Nelder-Mead method seemed to work relatively well.
